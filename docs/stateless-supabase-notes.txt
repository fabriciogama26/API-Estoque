Stateless migration notes for Supabase + Vercel
===============================================

Arquitetura geral
- Frontend (Vite/React) roda como deploy estático na Vercel.
- Todas as operações de dados ocorrem diretamente no Supabase via SDK JavaScript.
- Não há servidor Node dedicado; cada ação é stateless e reavalia os dados a partir do banco.

Variáveis de ambiente necessárias
- VITE_SUPABASE_URL: URL do projeto Supabase.
- VITE_SUPABASE_ANON_KEY: chave pública (anon) com permissões RLS configuradas.
- Para ambientes locais, defina estas variáveis em `.env.local`.

Modelagem esperada no Supabase
- pessoas(id uuid pk, nome text, matricula text unique, local text, cargo text, usuarioCadastro text,
  usuarioEdicao text, criadoEm timestamp, atualizadoEm timestamp, historicoEdicao jsonb).
- materiais(id uuid pk, nome text, fabricante text, validadeDias int, ca text, valorUnitario numeric,
  estoqueMinimo numeric, ativo boolean, usuarioCadastro text, usuarioAtualizacao text, dataCadastro timestamp,
  atualizadoEm timestamp).
- material_price_history(id uuid pk, materialId uuid fk, valorUnitario numeric,
  usuarioResponsavel text, criadoEm timestamp).
- entradas(id uuid pk, materialId uuid fk, quantidade numeric, dataEntrada timestamp,
  usuarioResponsavel text).
- saidas(id uuid pk, materialId uuid fk, pessoaId uuid fk, quantidade numeric,
  dataEntrega timestamp, dataTroca timestamp, status text, usuarioResponsavel text).
- acidentes(id uuid pk, matricula text, nome text, cargo text, data timestamp,
  diasPerdidos numeric, diasDebitados numeric, tipo text, agente text, cid text,
  lesao text, parteLesionada text, setor text, local text, cat text, observacao text,
  criadoEm timestamp, atualizadoEm timestamp).
- Ajuste nomes/colunas se necessário, mantendo correspondência com o código.

Regras de negócio implementadas no client
- Pessoas: valida campos obrigatórios e impede matrícula duplicada antes de gravar. Atualizações
  registram histórico de edições (json) com os campos alterados e usuário responsável.
- Materiais: valida dados obrigatórios, evita duplicidades por nome+fabricante e registra
  histórico de preço em `material_price_history` sempre que o valor unitário for alterado.
- Entradas: exige material válido, quantidade positiva e normaliza data; salva usuário responsável.
- Saídas: valida pessoa e material, recalcula saldo atual somando entradas - saídas no Supabase,
  bloqueia operação quando não há estoque e calcula `dataTroca` com base em validade em dias.
- Estoque/Dashboard: monta visão agregada lendo materiais, entradas, saídas (e pessoas para
  enriquecimento), filtrando por período (ano/mês ou intervalo) e recalculando saldos,
  históricos e alertas a cada requisição, mantendo comportamento estateless.
- Acidentes: normaliza strings, garante presença de dados obrigatórios, busca pessoa por
  matrícula para preencher dados faltantes e mantém campos numéricos não negativos.

Recomendações de RLS
- Pessoas, materiais, entradas, saídas e acidentes devem ter políticas permitindo acesso somente
  a usuários autenticados (`auth.uid()`).
- Para tabelas de histórico, permita insert/read conforme necessidade administrativa.
- Opcionalmente crie views ou stored procedures para agregações se o volume crescer.

Próximos passos sugeridos
- Configurar Supabase Auth com provedores desejados e garantir que o usuário usado na aplicação
  possa executar os CRUDs sob as regras RLS.
- Popular tabelas iniciais (materiais/pessoas) para validar cálculos.
- Automatizar migração dos dados anteriores (se existirem) usando scripts ou `.sql`.
- Monitorar limites de tempo das consultas no browser e considerar rotinas serverless se a lógica
  ficar pesada ou exigir chaves de serviço.
